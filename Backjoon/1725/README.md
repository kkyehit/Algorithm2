# 히스토그램
### 1725
***
- [BOJ 6549](https://www.acmicpc.net/problem/6549) 와 비슷한 문제
- 스택
	+ 막대의 번호를 스택에 넣는다. 만약 스택의 top에 해당하는 막대가 지금 push할 막대보다 크면 pop을 하면서 최대 넓이를 구한다.
		- 세로의 길이 : s.top(), 가로의 길이 : i 또는 (s.pop(); i -= s.top() + 1;)
	+ 스택에 요소가 남아 있다면 빼내면서 최대 넓이를 계산한다.
		- 세로의 길이 : s.top(), 가로의 길이 : N 또는 (s.pop(); N -= s.top() + 1;)

- 분할정복
	+ [BOJ 6549](https://www.acmicpc.net/problem/6549) 에서 사용한 방법과 같다.
	+ left, right의 범위가 주어졌을 때 이 범위 내에서 만들 수 있는 최대의 직사각형 넓이를 구한다.
		* 중간 막대부터 탐색을 시작하며 왼쪽 혹은 오른쪽 막대를 추가시켜서 넓이를 구하며 계산을 할 때마다 최대 넓이인지 확인한다.
			- 막대를 추가하면 세로의 길이는 지금까지 막대 높이의 최소값, 가로의 길이는 1이 증가한다.
			- 이 두 값을 계산한 것과 지금까지 결과와 비교한다.
			- res = max(res, x * y);
		* 추가할 막대를 선택할 때는 높이가 높은 막대 먼저 추가시킨다.
		* 마지막으로 아직 추가하지 않은 범위 내의 막대를 추가한다.
	+ [left, mid - 1]과 [mid + 1, right] 범위에 대해서도 같은 알고리즘을 수행한다.
	+ 위 세가지 결과중 가장 큰 넓이를 반환한다.
	+ 시간 복잡도 : O(NlogN)
***
[문제](https://www.acmicpc.net/problem/1725)
			 
