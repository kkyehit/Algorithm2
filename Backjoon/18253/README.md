# 최단경로와 쿼리 
### 18253
***
1. src.cpp
	- 다익스트라 알고리즘을 이용하여 (r1, c1) (r2, c2) 사이를 탐색한다.
	- 탐색할 때 최소값과 최대값을 넘어가지 않도록 한다.
	- 실패원인 : 최악의 경우 O(Q*(|N*M|*|log(N*M)|))
		+ 다익스트라 알고리즘 : O(ElogV) = O(|N*M|*|log(N*M)|)
2. src2.cpp
	- 다익스트라 알고리즘을 이용하여 (r1, c1) (r2, c2) 사이를 탐색한다.
	- 탐색할 때 중간의 열을 하나씩 골라서 모두 탐색한다.
		1. (1, mid) ~ (N, mid)를 모두 탐색한다.
		2. 가중치를 저장하는 배열을 이용하여 각 점에서 (r1, c1)와 (r2, c2) 까지의 가중치를 더한 값의 최소값을 출력한다.
		 	+ res = min(res, isVisited[r1][c1] + isVisited[r2][c2] - graph[i][(c1 + c2) / 2] );
		3. Q번 반복한다.
	- 실패원인 : 최악의 경우 O(Q*(|N*(N*M)*log(N*M)|))
	 	+ left = N*|(N*M/2)|*|log(N*M/2)|, right = N*|(N*M/2)|*|log(N*M/2)|
		+ 합지면 (|N*(N*M)*log(N*M)|))
		+ Q번 반복하므로 O(Q*(|N*(N*M)*log(N*M)|))
3. src3.cpp
	- 다익스트라 알고리즘을 이용하여 (r1, c1) (r2, c2) 사이를 탐색한다.
	- Query를 배열에 저장한 후 범위를 줄여가며 중간 지점을 포함하는 query에 대해 다익스트라 알고리즘을 수행한다.
		+ (1, mid) ~ (N, mid)를 지나는 query에 대해 알고리즘을 수행한다.
	- 특정 중간 지점을 포함하는 지점이 여러개라도 중간 지점으로 부터 범위 내의 점을 탐색하도록 다익스트라 알고리즘을 수행하면 다시 다익스트라 알고리즘을 한 번 수행하여 결과를 얻을 수 있다.
	- 실패원인 : 다익스트라 알고리즘을 수행 할 때마다 배열 전체를 초기화 하였다.
		+  시간복잡도 : O(|N*(N*M)*log(N*M)*log(M)| + M*(N*M))
			- 초기화 시간 : O(M*(N*M))
		+ 초기화 시간이 너무 커서 Q(M*(M*N))시간이 걸린다.
	- 해결방법 : 다익스트라 알고리즘을 수행 할 때마다 배열 전체가 아닌 사용할 범위만 초기화 한다.
		+ 시간복잡도 :  O(|N*(N*M)*log(N*M)*log(M)| +(log(M)*(N*M))
			- 초기화 시간 : O(log(M)*(N*M))
		+ 초기화 시간이 상대적으로 작아 O(|N*(N*M)*log(N*M)*log(M)|)시간이 걸린다.
4. src4.cpp
	- src3과 같은 방법이지만 함수 이름을 명확하게 정의하고 struct를 사용하여 연관된 데이터를 관리하였다.
	- 또한 선언 지정자인 auto 키워드를 사용하여 vector의 값에 접근하였다.
		+ auto : 초기화시에 초기화 값에 맞춰 자동으로 자료형을 판단하는 기능을 가진다.
		+ for(auto j : list)
			* list 벡터의 값이 차례로 j에 할당된다.
- 다른 실패원인
	1. 메모리 초과
		- priority_queue를 이용하여 다익스트라 알고리즘을 구현할 때에 pair<>를 사용하면 첫 번째 원소가 비용이 되야한다.
		- 다익스트라 알고리즘은 연결된 정점 중 가장 비용이 낮은 정점에서부터 탐색하기 떄문이다.
			+ priority_queue는 기본적으로 max hip 이지만
			+ priority_queue<pair<int,int> ,vector<pair<int,int> >,greater<pair<int,int> >로 선언하면 min hip이 되어 낮은 비용의 노드가 top에 위치한다.
		- 비용이 낮은 정점부터 탐색하지 않으면 시간복잡도가 커지고 메모리를 낭비하게 된다.
		
- Good Bye, BOJ 2019! > G
***
[문제](https://www.acmicpc.net/problem/18253)
			 
