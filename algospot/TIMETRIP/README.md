# 시간여행
### TIMETRIP
***
1. src.cpp
	+ 벨만 포드 알고리즘과 플로이드의 최단 거리 알고리즘으로 해결
	+ 처음에 벨만 포드 알고리즘만으로 풀었다가 사이클이 존재하는 경우를 고려하지 못해 오답
		- 안드로메다까지 갈 수 있는지 판별하는 방법과 무한 사이클 판별에 대한 해결을 못했다.
	+ 두 점과 가중치, 가중치의 음수를 저장하는 벡터와 각 정점이 갈 수 있는 정점을 표시하기 위한 배열 생성
		- 1. 플로이드 알고리즘을 이용하여 갈 수 있는 정점을 표시하는 배열 완성
		- 2. 벨만 포드 알고리즘을 이용하여 모든 정점까지의 최단 거리 배열 완성
		- 4. 간선을 순회하며 2 번에서 완성한 배열을 다시 갱신하는 경로가 있다면 사이클이 존재하는 것을 의미한다.
		- 5. 1번에서 만든 배열을 이용해서 접근 가능한지 확인한다. 접근이 불가능 하다면 UNREACHED를 출력하고
	접근이 가능하다면 사이클이 존재 하는지 확인한다. 만약 사이클이 존재한다면 INFINIT를 출력하고 사이클이
	존재하지 않는다면 값을 출력한다. 
		- 6. 무한히 미래로 가는 경우(최대 값을 구하는 경우)를 위해 가중치에 음수를 곱한 배열을 이용하여 2 ~ 5를 한 번더 수행한다.
	+ #649318
 ***
[문제](https://algospot.com/judge/problem/read/TIMETRIP)
			 
